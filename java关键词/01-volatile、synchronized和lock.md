# volatile详解

### 一、内存模型相关概念
    
    大家都知道，计算机再执行程序时，每一条指令都是在cpu执行的，而执行指令过程中，
 势必涉及到数据的读取和写入。由于程序运行过程中的面临数据是存放在主内存（物理内存）当中的。
 这时就存在一个问题，由于cpu执行的速度很快，而读取数据和向内存写入数据的过程跟cpu执行指令
 的速度比起来要满的很多，因此如果任何时候对数据的操作都需要通过和内存来进行交互来进行，会大大
 降低指令执行的速度，因此在cpu里面就有了告诉缓存。
    也就程序在运行过程中，会将运算需要的数据从主内存复制一份到cpu的高速缓存当中，那么cpu进行
 运算就可以直接从他的高速缓存中读取和写入数据，当运算结束后，再将高速缓存中的数据刷新到主内存中，
 
 ### 例如
    当线程执行 i = i + 1；这个语句时，会先从主内存中读取i的值，然后复制一份到高速缓存中，
然后cpu执行指令对i进行加1 的操作，然后将数据写入高速缓存，最后将高速缓存中的数据刷新到主内存中。

    这个代码在单线程执行是没有任何问题的。但是在多线程运行就会有问题，在多核cpu中，每一条线程都可
能运行于不同的cpu中，因此每一个线程运行时都有自己的高速缓存。


#### 解决缓存不一致的问题，通常有以下两种解决办法
	1、通过在总线加LOCK #锁的形式
	2、通过缓存一致性协议

在早期cpu中，是通过在总线加LUCk #锁的形似来解决缓存不一致的问题，因为cpu和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK #锁的话，也就是阻塞了cpu对其他部件的访问（内存），从而使得只能有一个cpu能使用这个变量的内存，比如上面的例子中一个线程执行i = i +1； 的操作，在总线上发出LOCK信号 ，那么只有等待这段代码 完全执行之后，其他cpu才能从变量 i 所在的内存读取变量的值，然后对其进行相应的操作在，这样解决了缓存不一致的问题，但是由于在锁住总线期间，其他CPU无法访问内存，导致效率低。

所以就出现了缓存一致性协议。最出名的就是 INtel 的MESI协议，MESI协议保证了每一个缓存中使用共享变量的副本是一致的。他的核心思想就是：当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将变量的缓存设置为无效的状态，因此当其他cpu需要读取这个变更量的时候，发现自己的缓存中缓存的该变量时无效的，那么他就会从内存中重新读取。

### 二、并发编程中的三个概念
	在并发编程中，我们通常会遇到以下三个问题：原子性问题 、可见性问题和有序性问题

#### 1、原子性
	原子性：即一个操作或多个操作，要么全部执行并且执行过程中不会被任何因素打断，药模就都部执行。很简单的一个例子就是银行转账问题。

#### 2、可见性
	可见性指的是多个线程访问同一个变量，一个线程修改了这个变量的值，其他线程能够立即的到修改的值，举一个简单的例子

```java
//线程1 执行的代码
int i = 0;

i  = 10;

//线程2执行的代码

j=i;

````
	假若执行线程1的时cpu1，执行线程2的是cpu2.由于线程执行之后，线程1会有一个高速缓存（工作内存），会将运行的结果 i = 10写入高速缓存中，不会理解写入到主内存中。此时线程2 去主内存中读取i的值，读到的i的值还是0而不是10。

#### 3、有序性



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
